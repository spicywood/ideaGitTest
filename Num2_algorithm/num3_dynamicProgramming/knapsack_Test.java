package Num2_algorithm.num3_dynamicProgramming;

/*
    动态规划算法介绍

    动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

    动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

    与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )

    动态规划可以通过填表的方式来逐步推进，得到最优解

 */
/*
    背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，

    如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)

    这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。


    算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。
    即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。
    则我们有下面的结果：
    (1) 当v[i][0]=v[0][j]=0;                                      // 表示 填入表 第一行和第一列是0
    (2) 当w[i]> j 时：v[i][j]=v[i-1][j]                            // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
    (3) 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}  // 当准备加入的新增的商品的容量小于等于当前背包的容量,

 */
public class knapsack_Test {
    public static void main(String[] args) {
        int[] w = {1,4,3};                  //物品重量
        int[] val = {1500,3000,2000};       //物品价值  就是前面讲的v[i]
        int m = 4;                          //物品容量
        int n = val.length;                //物品个数

        //为了记录放入商品的情况，我们定一个二维数组
        int[][] path = new int[n+1][m+1];

        //创建二维数组，表
        //v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int[n+1][m+1];
        //初始化第一行和第一列，这里在本程序中可以不去处理，默认为0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0;
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i] = 0;
        }

        //不处理第一行第一列
        for (int i = 1; i < v.length; i++) {
            for (int j = 1; j < v[0].length; j++) {
                //公式
                if (w[i-1] > j){
                    v[i][j] = v[i-1][j];
                } else {
                    //v[i][j] = Math.max(v[i-1][j],val[i-1] + v[i-1][j-w[i-1]]);
                    //为了记录商品放入背包的情况，不能简单使用上面的公式
                    if (v[i-1][j] < val[i-1] + v[i-1][j-w[i-1]]){
                        v[i][j] = val[i-1] + v[i-1][j-w[i-1]];
                        //把当前情况记录到path
                        path[i][j] = 1;
                    } else {
                        v[i][j] = v[i-1][j];
                    }
                }
            }
        }

        //输出v
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[i].length; j++) {
                System.out.print(v[i][j] + "\t");
            }
            System.out.println();
        }

        //输出最后放入那些商品
        int i = path.length - 1;
        int j = path[0].length - 1;
        while (i > 0 && j > 0){
            if (path[i][j] == 1){       //从path最后开始找
                System.out.printf("第%d个商品放入背包\n",i);
                j -= w[i-1];
            }
            i--;
        }

    }
}
